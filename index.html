<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿æ§åˆ¶3Dåœ£è¯æ ‘ (æœ€ç»ˆå®Œç¾ç‰ˆ)</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe Global Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@300;400&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Lato', sans-serif;
            color: #e2e8f0;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .ui-element {
            pointer-events: auto;
        }

        h1 {
            font-family: 'Cinzel', serif;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .glass-panel {
            background: rgba(10, 20, 15, 0.75);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 215, 0, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }
        
        .instruction-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Hidden Video for MediaPipe -->
    <video id="input-video" style="display:none;" playsinline></video>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-6">
        
        <!-- Header -->
        <div class="flex justify-between items-start">
            <div class="glass-panel p-6 rounded-xl max-w-md transition-all duration-700 transform translate-y-0 opacity-100" id="intro-panel">
                <h1 class="text-3xl text-yellow-400 mb-2 font-bold tracking-widest">NOEL LUMINA</h1>
                <p class="text-gray-300 text-xs mb-6 leading-relaxed border-l-2 border-yellow-600 pl-3">
                    WebGL æ²‰æµ¸å¼äº’åŠ¨ä½“éªŒ<br>è¯·å¼€å¯æ‘„åƒå¤´ï¼Œç”¨æ‰‹åŠ¿æŒæ§é­”æ³•
                </p>
                
                <div class="space-y-4">
                    <div class="flex items-center gap-4">
                        <div class="instruction-icon bg-green-900/40 text-green-400 border-green-500/30">
                            âœŠ
                        </div>
                        <div>
                            <p class="text-green-100 text-sm font-bold uppercase tracking-wide">æ¡æ‹³ (Fist)</p>
                            <p class="text-gray-400 text-xs">èšåˆåœ£è¯æ ‘</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="instruction-icon bg-yellow-900/40 text-yellow-400 border-yellow-500/30">
                            ğŸ–
                        </div>
                        <div>
                            <p class="text-yellow-100 text-sm font-bold uppercase tracking-wide">å¼ å¼€æ‰‹ (Open)</p>
                            <p class="text-gray-400 text-xs">ç‚¸å¼€ç²’å­ / ç§»åŠ¨è§†è§’</p>
                        </div>
                    </div>
                    <div class="flex items-center gap-4">
                        <div class="instruction-icon bg-red-900/40 text-red-400 border-red-500/30">
                            ğŸ‘Œ
                        </div>
                        <div>
                            <p class="text-red-100 text-sm font-bold uppercase tracking-wide">æåˆ (Pinch)</p>
                            <p class="text-gray-400 text-xs">æŠ“å–ç…§ç‰‡ (éœ€å…ˆç§»åŠ¨å…‰æ ‡ç„å‡†)</p>
                        </div>
                    </div>
                </div>

                <button id="start-btn" class="ui-element mt-8 w-full py-3 bg-gradient-to-r from-yellow-700 to-yellow-900 hover:from-yellow-600 hover:to-yellow-800 text-white font-serif tracking-widest text-sm uppercase rounded shadow-lg shadow-black/50 transition-all border border-yellow-600/30">
                    å¼€å¯ä½“éªŒ
                </button>
                <p id="loading-text" class="hidden text-xs text-center mt-3 text-yellow-500 animate-pulse tracking-wide">æ­£åœ¨æ ¡å‡†ä¼ æ„Ÿå™¨...</p>
            </div>

            <!-- Upload Control -->
            <div class="glass-panel p-4 rounded-full ui-element hover:bg-white/10 transition-all cursor-pointer group active:scale-95" onclick="document.getElementById('photo-upload').click()">
                <div class="flex flex-col items-center justify-center w-12 h-12">
                    <span class="text-2xl text-gray-400 group-hover:text-yellow-400 transition-colors">ğŸ“·</span>
                </div>
                <!-- å…è®¸é€‰æ‹©å¤šä¸ªå›¾ç‰‡ï¼Œæ”¯æŒ jpg, png, webp -->
                <input type="file" id="photo-upload" multiple accept="image/png, image/jpeg, image/webp" class="hidden">
            </div>
        </div>

        <!-- Feedback HUD -->
        <div class="flex flex-col items-center mb-8 gap-2">
            <div id="gesture-feedback" class="glass-panel px-10 py-3 rounded-full text-yellow-400 font-serif tracking-widest text-sm opacity-0 transition-opacity duration-300">
                SYSTEM STANDBY
            </div>
            <p class="text-xs text-gray-500 font-mono opacity-50 uppercase">Use Cursor to Aim</p>
        </div>
    </div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 1600,
            colors: {
                green: 0x2F4F4F,
                gold: 0xFFD700,
                red: 0xB22222,
                white: 0xFFFFFF
            },
            treeHeight: 35,
            treeRadius: 14,
            camZ: 45
        };

        // --- State Management ---
        const STATE = {
            mode: 'TREE', 
            handDetected: false,
            handPosition: { x: 0, y: 0 },
            rotation: 0,
            targetRotation: 0,
            photos: [],
            lastGesture: 'OPEN',
            gestureFrameCount: 0,
            isPinching: false 
        };

        // --- Global Variables ---
        let camera, scene, renderer, composer, bloomPass;
        let particles = []; 
        let photoMeshes = [];
        let cursorMesh;
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let focusedPhoto = null;
        let photoGroups = [];
        let loader = new THREE.TextureLoader();
        let maxAnisotropy = 1;
        
        // --- Initialization ---
        const init = () => {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.015);
            scene.background = new THREE.Color(0x020202);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, CONFIG.camZ);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: false, 
                powerPreference: "high-performance",
                logarithmicDepthBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.9; // Slightly lower exposure
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
            container.appendChild(renderer.domElement);

            // Post Processing
            const renderScene = new RenderPass(scene, camera);
            
            // FIX 1: Higher Threshold (0.85) so photos (usually ~0.5-0.8 brightness) don't glow
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.85; 
            bloomPass.strength = 1.5; 
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
            scene.add(ambientLight);
            
            // Stronger lights to interact with materials
            const spotLight = new THREE.SpotLight(0xffd700, 2000);
            spotLight.position.set(20, 50, 20);
            spotLight.decay = 2;
            spotLight.distance = 200;
            scene.add(spotLight);
            
            const rimLight = new THREE.SpotLight(0x4455ff, 800);
            rimLight.position.set(-20, 20, -20);
            scene.add(rimLight);

            // Objects
            createParticles();
            createDefaultPhotos();
            createCursor();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate);
        };

        const createCursor = () => {
            const geometry = new THREE.RingGeometry(0.8, 1, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide,
                depthTest: false 
            });
            cursorMesh = new THREE.Mesh(geometry, material);
            cursorMesh.renderOrder = 999;
            cursorMesh.visible = false;
            scene.add(cursorMesh);
        };

        // --- Particle System ---
        const createParticles = () => {
            // FIX 2: Boost Emissive Intensity so they glow even with high threshold
            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, 
                metalness: 1.0, 
                roughness: 0.1, 
                emissive: 0xffaa00,
                emissiveIntensity: 3.0 
            });
            
            const matGreen = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.green, 
                metalness: 0.2, 
                roughness: 0.8 
            });
            
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, 
                metalness: 0.5, 
                roughness: 0.2, 
                emissive: 0xff0000,
                emissiveIntensity: 4.0 
            });

            const geomSphere = new THREE.SphereGeometry(0.35, 12, 12);
            const geomCube = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            
            const meshGold = new THREE.InstancedMesh(geomSphere, matGold, 400);
            const meshGreen = new THREE.InstancedMesh(geomCube, matGreen, 800);
            const meshRed = new THREE.InstancedMesh(geomSphere, matRed, 400);

            scene.add(meshGold);
            scene.add(meshGreen);
            scene.add(meshRed);

            const distribute = (mesh, type, offsetIndex) => {
                const count = mesh.count;
                const dummy = new THREE.Object3D();

                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const y = -12 + t * CONFIG.treeHeight;
                    const radius = (1 - t) * CONFIG.treeRadius;
                    const angle = i * 2.399 + offsetIndex;
                    
                    const tx = Math.cos(angle) * radius + (Math.random()-0.5);
                    const tz = Math.sin(angle) * radius + (Math.random()-0.5);
                    const cx = (Math.random() - 0.5) * 60;
                    const cy = (Math.random() - 0.5) * 40;
                    const cz = (Math.random() - 0.5) * 30;

                    dummy.position.set(tx, y, tz);
                    dummy.scale.setScalar(Math.random() * 0.5 + 0.5);
                    dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    particles.push({
                        mesh: mesh,
                        index: i,
                        treePos: new THREE.Vector3(tx, y, tz),
                        chaosPos: new THREE.Vector3(cx, cy, cz),
                        currentPos: new THREE.Vector3(tx, y, tz),
                        wobbleOffset: Math.random() * 100,
                        wobbleSpeed: Math.random() * 0.5 + 0.5
                    });
                }
            };

            distribute(meshGold, 'gold', 0);
            distribute(meshGreen, 'green', 1);
            distribute(meshRed, 'red', 2);
        };

        // --- Photo System ---
        const createPhoto = (texture, index) => {
            const group = new THREE.Group();
            
            texture.anisotropy = maxAnisotropy;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            let aspect = 0.8;
            if (texture.image && texture.image.width && texture.image.height) {
                aspect = texture.image.width / texture.image.height;
            }
            
            const width = 5;
            const height = width / aspect;

            const pGeo = new THREE.PlaneGeometry(width, height);
            const pMat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });
            const pMesh = new THREE.Mesh(pGeo, pMat);
            
            pMesh.position.z = 0.08; 
            pMesh.name = "photo_surface"; 
            
            // FIX 3: Darker Frame Color (0xeeeeee) so it doesn't trigger bloom
            const fWidth = width + 1; 
            const fHeight = height + 2.5; 
            const fGeo = new THREE.PlaneGeometry(fWidth, fHeight);
            const fMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, side: THREE.DoubleSide });
            const fMesh = new THREE.Mesh(fGeo, fMat);
            
            pMesh.position.y = (fHeight - height) / 2 - 0.5;

            group.add(fMesh);
            group.add(pMesh);

            const cx = (Math.random() - 0.5) * 40;
            const cy = (Math.random() - 0.5) * 30;
            const cz = (Math.random() - 0.5) * 20;

            group.userData = {
                chaosPos: new THREE.Vector3(cx, cy, cz),
                treePos: new THREE.Vector3(0, 15, 0),
                velocity: new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, 0)
            };
            
            group.scale.set(0,0,0);
            
            scene.add(group);
            photoMeshes.push(group);
            photoGroups.push(group);
        };

        const createDefaultPhotos = () => {
            const imageUrls = [
                './c2804e004b3298fd844f6fc931dabd51.jpg',
                './3937903cff4c216da2d7b8e10e09bebb.jpg',
                './508a188f8d2c0f8d17d312e3f923b294.jpg',
                './3bd9c41b6ec25b00526d612af704615e.jpg',
            ];

            imageUrls.forEach((url, i) => {
                loader.load(url, (tex) => {
                    tex.colorSpace = THREE.SRGBColorSpace;
                    createPhoto(tex, i);
                }, undefined, () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512; canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#C41E3A';
                    ctx.fillRect(0,0,512,512);
                    ctx.fillStyle = '#fff';
                    ctx.fillText('Noel', 200, 256);
                    const t = new THREE.CanvasTexture(canvas);
                    t.colorSpace = THREE.SRGBColorSpace;
                    createPhoto(t, i);
                });
            });
        };

        // --- Logic Update ---
        const updateState = (delta, time) => {
            
            // FIX 4: Dynamic Bloom Strength
            // If focused, turn off bloom completely to ensure clear text/image
            const targetBloomStrength = (STATE.mode === 'FOCUS') ? 0.0 : 1.5;
            // Smoothly interpolate bloom
            bloomPass.strength += (targetBloomStrength - bloomPass.strength) * 4.0 * delta;


            const dummy = new THREE.Object3D();
            
            // 1. Cursor & Camera
            if (STATE.mode === 'EXPLODE' || STATE.mode === 'FOCUS') {
                if (STATE.handDetected) {
                    raycaster.setFromCamera(STATE.handPosition, camera);
                    
                    const cursorDist = 20;
                    const cursorPos = new THREE.Vector3()
                        .copy(raycaster.ray.direction)
                        .multiplyScalar(cursorDist)
                        .add(raycaster.ray.origin);
                        
                    cursorMesh.position.copy(cursorPos);
                    cursorMesh.lookAt(camera.position);
                    cursorMesh.visible = true;

                    if (STATE.isPinching) {
                        cursorMesh.scale.set(0.5, 0.5, 0.5);
                        cursorMesh.material.color.set(0xff0000);
                    } else {
                        cursorMesh.scale.set(1, 1, 1);
                        cursorMesh.material.color.set(0xffffff);
                    }

                    if (STATE.mode === 'EXPLODE') {
                        const targetRot = STATE.handPosition.x * 0.5; 
                        STATE.rotation += (targetRot - STATE.rotation) * 2.0 * delta;
                        
                        camera.position.x = Math.sin(STATE.rotation) * CONFIG.camZ;
                        camera.position.z = Math.cos(STATE.rotation) * CONFIG.camZ;
                        camera.lookAt(0, 0, 0);
                    }
                } else {
                    cursorMesh.visible = false;
                }
            } else {
                STATE.rotation += delta * 0.2;
                camera.position.x = Math.sin(STATE.rotation) * CONFIG.camZ;
                camera.position.z = Math.cos(STATE.rotation) * CONFIG.camZ;
                camera.lookAt(0, 5, 0);
                cursorMesh.visible = false;
            }

            // 2. Particles
            const lerpSpeed = 4.0 * delta;
            particles.forEach(p => {
                let target = (STATE.mode === 'TREE') ? p.treePos : p.chaosPos;
                p.currentPos.lerp(target, lerpSpeed);
                const wobble = Math.sin(time * p.wobbleSpeed + p.wobbleOffset) * 0.2;
                dummy.position.copy(p.currentPos);
                if (STATE.mode !== 'TREE') dummy.position.y += wobble;
                const scaleTarget = (STATE.mode === 'TREE') ? 1.0 : 0.6;
                dummy.scale.setScalar(scaleTarget);
                dummy.lookAt(camera.position); 
                if (STATE.mode === 'TREE') dummy.rotation.set(0,0,0); 
                dummy.updateMatrix();
                p.mesh.setMatrixAt(p.index, dummy.matrix);
            });
            scene.children.filter(c => c.isInstancedMesh).forEach(m => m.instanceMatrix.needsUpdate = true);

            // 3. Photos
            photoMeshes.forEach(group => {
                if (STATE.mode === 'TREE') {
                    group.scale.lerp(new THREE.Vector3(0,0,0), lerpSpeed);
                    group.position.lerp(group.userData.treePos, lerpSpeed);
                } else {
                    group.visible = true;
                    if (STATE.mode === 'FOCUS' && group === focusedPhoto) {
                        const frontPos = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(12));
                        group.position.lerp(frontPos, lerpSpeed * 3);
                        group.lookAt(camera.position);
                        group.scale.lerp(new THREE.Vector3(1.5, 1.5, 1.5), lerpSpeed);
                    } else {
                        let target = group.userData.chaosPos.clone();
                        if (STATE.mode === 'FOCUS') {
                            group.scale.lerp(new THREE.Vector3(0.5, 0.5, 0.5), lerpSpeed);
                        } else {
                            group.scale.lerp(new THREE.Vector3(1, 1, 1), lerpSpeed);
                            target.y += Math.sin(time + group.id) * 0.5;
                        }
                        group.position.lerp(target, lerpSpeed);
                        group.lookAt(camera.position);
                    }
                }
            });
        };

        const animate = () => {
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            updateState(delta, time);
            composer.render();
        };

        const onWindowResize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        };

        // --- MediaPipe Logic ---
        const videoElement = document.getElementById('input-video');
        const startBtn = document.getElementById('start-btn');
        const feedbackEl = document.getElementById('gesture-feedback');
        const loadingText = document.getElementById('loading-text');
        
        startBtn.addEventListener('click', async () => {
            startBtn.disabled = true;
            startBtn.classList.add('opacity-50');
            loadingText.classList.remove('hidden');

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640, height: 480
            });
            await cameraUtils.start();

            document.getElementById('intro-panel').classList.add('opacity-0');
            setTimeout(()=> document.getElementById('intro-panel').style.display = 'none', 700);
            feedbackEl.style.opacity = '1';
        });

        const onHandsResults = (results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                const lm = results.multiHandLandmarks[0];
                
                let ndcX = (1 - lm[9].x) * 2 - 1; 
                let ndcY = (1 - lm[9].y) * 2 - 1;
                
                ndcX *= 1.3;
                ndcY *= 1.3;
                ndcY += 0.2; 

                ndcX = Math.max(-1, Math.min(1, ndcX));
                ndcY = Math.max(-1, Math.min(1, ndcY));

                STATE.handPosition.x = ndcX;
                STATE.handPosition.y = ndcY;

                processGesture(lm);
            } else {
                STATE.handDetected = false;
                STATE.gestureFrameCount = 0;
                STATE.isPinching = false;
                updateFeedback("SEARCHING HAND...", "gray");
            }
        };

        const processGesture = (lm) => {
            const dist = (i, j) => Math.sqrt(
                Math.pow(lm[i].x - lm[j].x, 2) + 
                Math.pow(lm[i].y - lm[j].y, 2) + 
                Math.pow(lm[i].z - lm[j].z, 2)
            );

            const scale = dist(0, 9);
            if (scale < 0.02) return;

            const dThumbIndex = dist(4, 8) / scale;
            const dMiddle = dist(12, 0) / scale;
            const dRing = dist(16, 0) / scale;
            const dPinky = dist(20, 0) / scale;
            const otherFingersExt = (dMiddle + dRing + dPinky) / 3;

            let detected = STATE.lastGesture;

            if (otherFingersExt < 1.0) {
                detected = 'FIST';
            } else {
                const pinchThreshold = STATE.isPinching ? 0.40 : 0.20;
                if (dThumbIndex < pinchThreshold) {
                    detected = 'PINCH';
                } else {
                    detected = 'OPEN';
                }
            }

            if (detected === STATE.lastGesture) {
                STATE.gestureFrameCount++;
            } else {
                STATE.gestureFrameCount = 0;
                STATE.lastGesture = detected;
            }

            if (STATE.gestureFrameCount > 3) {
                executeState(detected);
            }
        };

        const executeState = (gesture) => {
            if (gesture === 'PINCH') {
                STATE.isPinching = true;
                if (STATE.mode !== 'TREE') {
                    raycaster.setFromCamera(STATE.handPosition, camera); 
                    
                    const intersects = raycaster.intersectObjects(photoGroups, true); 
                    
                    if (intersects.length > 0) {
                        let target = intersects[0].object;
                        while(target.parent && !photoMeshes.includes(target)) {
                            target = target.parent;
                        }
                        if (photoMeshes.includes(target)) {
                            focusedPhoto = target;
                            STATE.mode = 'FOCUS';
                        }
                    }
                }
                updateFeedback("PINCH: GRAB MEMORY", "red");
            } else if (gesture === 'FIST') {
                STATE.isPinching = false;
                STATE.mode = 'TREE';
                focusedPhoto = null;
                updateFeedback("FIST: ASSEMBLE", "green");
            } else if (gesture === 'OPEN') {
                STATE.isPinching = false;
                if (STATE.mode === 'FOCUS') {
                    STATE.mode = 'EXPLODE';
                    focusedPhoto = null;
                } else if (STATE.mode === 'TREE') {
                    STATE.mode = 'EXPLODE';
                }
                updateFeedback("OPEN: CHAOS MODE", "yellow");
            }
        };

        const updateFeedback = (text, colorKey) => {
            const colors = {
                red: "text-red-400 border-red-500/50 shadow-red-500/30",
                green: "text-green-400 border-green-500/50 shadow-green-500/30",
                yellow: "text-yellow-400 border-yellow-500/50 shadow-yellow-500/30",
                gray: "text-gray-400 border-gray-500/20 shadow-none"
            };
            feedbackEl.textContent = text;
            feedbackEl.className = `glass-panel px-10 py-3 rounded-full font-serif tracking-widest text-sm transition-all duration-300 border shadow-lg ${colors[colorKey]}`;
        };

        document.getElementById('photo-upload').addEventListener('change', (e) => {
            const files = e.target.files;
            if(!files.length) return;
            
            photoMeshes.forEach(m => scene.remove(m));
            photoMeshes = [];
            photoGroups = [];
            
            Array.from(files).forEach((file, i) => {
                const url = URL.createObjectURL(file);
                
                loader.load(url, (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace; 
                    createPhoto(texture, i);
                    URL.revokeObjectURL(url);
                }, undefined, (err) => {
                    console.error('Error loading image', err);
                });
            });
        });

        init();
    </script>
</body>
</html><!-- é‡æ–°éƒ¨ç½² -->
